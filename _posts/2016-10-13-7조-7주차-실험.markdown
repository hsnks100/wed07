
# 개요
Interrupt 방식을 활용하여 GPIO 제어 및 UART 통신을 실험한다.

# 세팅

##eclipse
5주차 실험의 scatter file을 위한 setting과 6주차 실험의 라이브러리를 추가 이후만 살펴보겠다.
C++ 프로젝트는 동작하지 않는 경우가 많기 때문에 C 프로젝트를 생성하였다.
![](../images/experiment04/cproject.PNG)

<br>
그리고 STM32 Peripheral Library를 추가하였다.
여기서 stm32f10x_conf.h, stm32f10x_it.h, stm32f10x_it.c를 프로젝트 폴더에 추가하였기 때문에
프로젝트 폴더를 새롭게 추가해 주었다.
![](../images/experiment04/tree.PNG)
![](../images/experiment04/include.PNG)

*그 외 자질구레한 세팅 추가???

# 기본 개념 
CPU가 특정 이벤트를 기다릴때 Interrupt와 Polling 두 가지 방식이 있다.
Polling 방식은 CPU가 특정 이벤트의 발생을 처리하기 위해 이벤트가 발생할때까지 모든 연산을 이벤트가 발생하는지 감시하는데 소모한다.
<br>

Interrupt는 CPU가 다른 연산을 수행하고 있던 도중이라도 특정 이벤트가 발생하면 연산을 멈추고 이벤트 처리를 위한 연산을 수행한다. 
이벤트 수행이 끝나면 다시 이전 작업으로 돌아간다.

# 구현 


# 실험 결과

terminal을 통해 확인한 결과
![](../images/experiment04/terminal.PNG)

# 결론


# 전체 소스

```cpp
#include "stm32f10x.h"

/* User defined function prototypes */

void Delay(int d){
  int i=0;
  for(i=0; i<1000000; i++){
    ;
  }
}

void send_string(char buf[]) {
	char *s = buf;
	while (*s) {
		while (USART_GetFlagStatus(USART1, USART_FLAG_TXE) == RESET)
			;
		USART_SendData(USART1, *s++);
	}
}

void GPIOD_Init(void);
void USART1_Init(void);
void led_toggle(void);
void EXTI11_Config(void);

int main(void)
{
  /* Initialize GPIOA PIN8 */
  GPIOD_Init();
  /* Initialize USART1 */
  USART1_Init();
//  Configure_PD0();
  EXTI11_Config();
//  AFIO_EXTICR3_EXTI11 = AFIO_EXTICR3_EXTI11_PD;


  /*RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOD, ENABLE);*/
  /*GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;*/
  /*GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;*/
  /*GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;*/
  /*GPIO_Init(GPIOD, &GPIO_InitStructure);*/

  while(1)
  {
    // 踰꾪듉 �낅젰��
    /*USART_SendData(USART1, 'T');*/
    /* Do nothing, all happens in ISR */
  }
}

/***********************************************
 * Initialize GPIOA PIN8 as push-pull output
 ***********************************************/
void GPIOD_Init(void)
{
  GPIO_InitTypeDef GPIO_InitStructure;
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOD, ENABLE);

  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
  GPIO_Init(GPIOD, &GPIO_InitStructure);

  /*RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);*/
  /*GPIO_Init(GPIOD, &gpioa_init_struct); */
  /*GPIO_SetBits(GPIOA, GPIO_Pin_8);*/
}

/*****************************************************
 * Initialize USART1: enable interrupt on reception
 * of a character
 *****************************************************/
void USART1_Init(void)
{
  /* USART configuration structure for USART1 */
  USART_InitTypeDef usart1_init_struct;
  /* Bit configuration structure for GPIOA PIN9 and PIN10 */
  GPIO_InitTypeDef gpioa_init_struct;

  /* Enalbe clock for USART1, AFIO and GPIOA */
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1 | RCC_APB2Periph_AFIO |
      RCC_APB2Periph_GPIOA, ENABLE);

  /* GPIOA PIN9 alternative function Tx */
  gpioa_init_struct.GPIO_Pin = GPIO_Pin_9;
  gpioa_init_struct.GPIO_Speed = GPIO_Speed_50MHz;
  gpioa_init_struct.GPIO_Mode = GPIO_Mode_AF_PP;
  GPIO_Init(GPIOA, &gpioa_init_struct);
  /* GPIOA PIN9 alternative function Rx */
  gpioa_init_struct.GPIO_Pin = GPIO_Pin_10;
  gpioa_init_struct.GPIO_Speed = GPIO_Speed_50MHz;
  gpioa_init_struct.GPIO_Mode = GPIO_Mode_IN_FLOATING;
  GPIO_Init(GPIOA, &gpioa_init_struct);

  /* Enable USART1 */
  USART_Cmd(USART1, ENABLE);
  /* Baud rate 9600, 8-bit data, One stop bit
   * No parity, Do both Rx and Tx, No HW flow control
   */
  usart1_init_struct.USART_BaudRate = 9600;
  usart1_init_struct.USART_WordLength = USART_WordLength_8b;
  usart1_init_struct.USART_StopBits = USART_StopBits_1;
  usart1_init_struct.USART_Parity = USART_Parity_No;
  usart1_init_struct.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
  usart1_init_struct.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
  /* Configure USART1 */
  USART_Init(USART1, &usart1_init_struct);
  /* Enable RXNE interrupt */
  USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);
  /* Enable USART1 global interrupt */
  NVIC_EnableIRQ(USART1_IRQn);
}

void EXTI11_Config(void)
{
	GPIO_InitTypeDef GPIO_InitStructure;
	  EXTI_InitTypeDef EXTI_InitStructure;
	  NVIC_InitTypeDef NVIC_InitStructure;
  /* Enable GPIOA clock */
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOD, ENABLE);


  /* Configure PA.00 pin as input pull down */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD;
  GPIO_Init(GPIOD, &GPIO_InitStructure);


  /* Enable AFIO clock */
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);

  /* Connect EXTI0 Line to PA.00 pin */
  GPIO_EXTILineConfig(GPIO_PortSourceGPIOD, GPIO_PinSource11);


  EXTI_InitStructure.EXTI_Line = EXTI_Line11;
  /* Enable interrupt */
  EXTI_InitStructure.EXTI_LineCmd = ENABLE;
  /* Interrupt mode */
  EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
  /* Triggers on rising and falling edge */
  EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising_Falling;
  /* Add to EXTI */
  EXTI_Init(&EXTI_InitStructure);

  /* Add IRQ vector to NVIC */
  /* PB12 is connected to EXTI_Line12, which has EXTI15_10_IRQn vector */
  NVIC_InitStructure.NVIC_IRQChannel = EXTI15_10_IRQn;
  /* Set priority */
  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x00;
  /* Set sub priority */
  NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x01;
  /* Enable interrupt */
  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
  /* Add to NVIC */
  NVIC_Init(&NVIC_InitStructure);
}

/*******************************************
 * Toggle LED
 *******************************************/
void led_toggle(void)
{
  GPIO_SetBits(GPIOD, GPIO_Pin_2);
  Delay(1000);
  GPIO_ResetBits(GPIOD, GPIO_Pin_2);
  Delay(1000);
}

/**********************************************************
 * USART1 interrupt request handler: on reception of a
 * character 't', toggle LED and transmit a character 'T'
 *********************************************************/
void USART1_IRQHandler(void) {
	char buf;
	int i = 0;
	/* RXNE handler */
	if (USART_GetITStatus(USART1, USART_IT_RXNE) != RESET) {
		USART_ClearITPendingBit(USART1, USART_IT_RXNE);
		buf = (unsigned char) USART_ReceiveData(USART1);
		for (i = 0; i < buf; i++) {
			led_toggle();
		}

	}
//	USART_ClearITPendingBit(USART1, USART_IT_RXNE);
}

void EXTI15_10_IRQHandler(void) {
	/* Make sure that interrupt flag is set */
	unsigned char buf[] = "Wed_team07";

	/* RXNE handler */

	if (EXTI_GetITStatus(EXTI_Line11) != RESET) {
		send_string(buf);
	}

	/* Clear interrupt flag */
	EXTI_ClearITPendingBit(EXTI_Line11);
}
```
